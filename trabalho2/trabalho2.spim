.data
mensagem_de_erro: .asciiz "Entradas invalidas.\n"
nao_primo: .asciiz "O modulo nao eh primo.\n"
numero: .word 65536

.text

main:
lw $t9, numero
#addi $t9, $zero, 32767	# t9 e o 32767
#addi $t9, $t9, 32767	# t9 = 32767 + 32767 = 65534
#addi $t9, $t9, 1	# t9 = 65534 + 1 = 65535
#addiu $t9, $zero, 65535
addi $t8, $zero, 3	# t8 = 3
addi $t7, $zero, 1	# t7 = 1
addi $t6, $zero, 2	# t6 = 2
addi $t4, $zero, 25	# t4 = 25

li $v0, 5		# cod le inteiro
syscall 		# le o int
move $t0, $v0		# salva o numero em t0
move $a0, $t0		# copia o numero pra a0, vamos passar a0 para a funcao is_lower_than_parameter
jal is_lower_than_parameter 	# chama a funcao para verificar se o numero atende aos parametros do enunciado
#fzr um beq
beq $v1, $zero, end	# se v1 = 0, retorno da funcao indica erro. Assim, termina-se o programa

li $v0, 5		# cod le inteiro
syscall 		# le o int
move $t1, $v0		# salva o numero 2 em t1
move $a0, $t1		# copia o numero pra a0, vamos passar a0 para a funcao is_lower_than_parameter
jal is_lower_than_parameter	# chama a funcao para verificar se o numero atende aos parametros do enunciado
#fzr um beq
beq $v1, $zero, end	# se v1 = 0, retorno da funcao indica erro. Assim, termina-se o programa

li $v0, 5		# cod le inteiro
syscall 		# le o int
move $t2, $v0		# salva o numero 3 em t2
move $a0, $t2		# copia o numero pra a0, vamos passar a0 para a funcao is_lower_than_parameter
jal is_lower_than_parameter	# chama a funcao para verificar se o numero atende aos parametros do enunciado
#fzr um beq
beq $v1, $zero, end	# se v1 = 0, retorno da funcao indica erro. Assim, termina-se o programa

# verificar se o t2 e primo
move $a0, $t2		# copia o numero pra a0, vamos passar a0 para a funcao is_prime
jal is_prime
beq $v1, $zero, end	# se v1 = 0, retorno da funcao indica erro. Assim, termina-se o programa

# exponenciar tudo
	# t0 * t0 % t2 ; resultado * t0 % t2 ===>>> t1 vezes
	# precisaremos de um contador
move $t5, $t0
sub $t3, $t3, $t3		# contador t3 = 0
exponenciar:
multu $t5, $t0			# t0 ^2 ==>> base ^2 , na primeira vez ; nas outras : resultado * base
mflo $t4			# resultado anterior em t4
divu $t4, $t2			# t4 / t2 ==>> base^2 / modulo
mfhi $t5			# t5 = t4 % t2 ===>>> t5 = base^2 mod modulo
addi $t3, $t3, 1		# t3 + 1 ==>> contador ++
slt $t6, $t3, $t1		# t3 < t1 ? ==>> contador < expoente ? se sim, repete ; se nao, exponenciacao concluida
beq $t6, 1, exponenciar		# contador < expoente ? se sim, repete ; se nao, exponenciacao concluida

# resultado em t5
move $a0, $t5			# resultado agora em a0
li $v0, 1			# print int code
syscall 			# print do resultado

end:
#------END-----------------------------------------------------------------------------------------------------#
li $v0, 10 		# codigo de saida de programa
syscall			# chama a syscall para return 0

#---------------------------FUNCOES----------------------------------------------------------------------------#

is_lower_than_parameter:
slt $t3, $a0, $t9	# a0 < 65535 ? t3 = 1, else t3 = 0
beq $t3, $zero, error	# se t3 = 0 , erro.
# verificar se o num <= 0
beq $a0, $zero, error	# se numero = 0, erro
slti $t3, $a0, 0	# se numero < 0, t3 =1, else t3 = 0
bne $t3, $zero, error	# se t3 != 0, erro
sub $v1, $v1, $v1	# v1 = 0, endereco de retorno de funcao
addi $v1, $v1, 1	# v1 = 1, retorno verdadeiro

jr $ra

error:
# print da mensagem de erro
li $v0, 4		# cod print string
la $a0, mensagem_de_erro # carrega a mensagem no a0
syscall			# print mensagem de erro
sub $v1, $v1, $v1	# v1 = 0, endereco de retorno de funcao, 0 = erro
jr $ra			# volta para onde parou

is_prime:
# verificar se o num <= 3
slti $t3, $a0, 4	# se numero < 4, t3 =1, else t3 = 0
bne $t3, $zero, verifica_mod_2_3	# se t3 != 0, num >= 4, pula pro outro if
beq $a0, $t7, not_prime	# se num = 1 , nao e primo
# ver se num = 2
addi $t7, $t7, 1	# t7 = 2
beq $a0, $t7, sai_do_while	# se num for 2, e primo
# ver se num = 3
addi $t7, $t7, 1	# t7 = 3
beq $a0, $t7, sai_do_while	# se num = 3 , e primo

verifica_mod_2_3:
div $a0, $t6		# num / 2 -> HI = resto
mfhi $t5		# t5 = resto (HI)
beq $t5, $zero, not_prime	# se o resto da div for 0, nao e primo
div $a0, $t8		# num / 3 -> HI = resto
mfhi $t5		# t5 = resto de num/3
beq $t5, $zero, not_prime 	# se o resto da div for 0, nao e primo

addi $t5, $a0, 1	# t5 = num + 1
while:
slt $t3, $t4, $t5	# t4 < num + 1 ? t3 = 1, else t3 = 0 ; t4 = 25, inicialmente
beq $t3, $zero, sai_do_while	# se t4 > num + 1 sai do while
div $a0, $t4		# num / t4 
mfhi $t5		# t5 = resto de num / t4
beq $t5, $zero, not_prime	# se o resto da div for 0, nao e primo
addi $t4, $t4, 2	# t4 + 2
div $a0, $t4		# num / t4+2
mfhi $t5		# t5 = resto de num / t4+2
beq $t5, $zero, not_prime	# se o resto da div for 0, nao e primo
addi $t4, $t4, 4	# t4 = t4 + 4
addi $t5, $a0, 1	# t5 = num + 1
# fazer t4 * t4 => i * i
multu $t4, $t4		# t4 ^ 2
mflo $t4		# t4 = low t4^2
j while

sai_do_while:
sub $v1, $v1, $v1	# v1 = 0, endereco de retorno de funcao
addi $v1, $v1, 1	# v1 = 1, retorno verdadeiro

jr $ra

not_prime:
# print da mensagem de erro
li $v0, 4		# cod print string
la $a0, nao_primo	# carrega a mensagem no a0
syscall			# print mensagem de erro
sub $v1, $v1, $v1	# v1 = 0, endereco de retorno de funcao, 0 = erro
jr $ra			# volta para onde parou


modular_exponentiation:


jr $ra
