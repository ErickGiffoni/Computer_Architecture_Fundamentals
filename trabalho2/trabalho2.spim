.data
mensagem_de_erro: .asciiz "Entradas invalidas.\n"
nao_primo: .asciiz "O modulo nao eh primo.\n"
numero: .word 65536
exp_mod: .asciiz "A exponencial modular "
elevado: .asciiz " elevado a "
mod: .asciiz " (mod "
fecha_mod: .asciiz ") eh "
barra_n: .asciiz ".\n"

.text

main:
lw $t9, numero
#addi $t9, $zero, 32767	# t9 e o 32767
#addi $t9, $t9, 32767	# t9 = 32767 + 32767 = 65534
#addi $t9, $t9, 1	# t9 = 65534 + 1 = 65535
#addiu $t9, $zero, 65535
addi $t8, $zero, 3	# t8 = 3
addi $t7, $zero, 1	# t7 = 1
addi $t6, $zero, 2	# t6 = 2
addi $t4, $zero, 25	# t4 = 25

li $v0, 5		# cod le inteiro
syscall 		# le o int
move $t0, $v0		# salva o numero em t0
move $a0, $t0		# copia o numero pra a0, vamos passar a0 para a funcao is_lower_than_parameter
jal is_lower_than_parameter 	# chama a funcao para verificar se o numero atende aos parametros do enunciado
#fzr um beq
beq $v1, $zero, end	# se v1 = 0, retorno da funcao indica erro. Assim, termina-se o programa

li $v0, 5		# cod le inteiro
syscall 		# le o int
move $t1, $v0		# salva o numero 2 em t1
move $a0, $t1		# copia o numero pra a0, vamos passar a0 para a funcao is_lower_than_parameter
jal is_lower_than_parameter	# chama a funcao para verificar se o numero atende aos parametros do enunciado
#fzr um beq
beq $v1, $zero, end	# se v1 = 0, retorno da funcao indica erro. Assim, termina-se o programa

li $v0, 5		# cod le inteiro
syscall 		# le o int
move $t2, $v0		# salva o numero 3 em t2
move $a0, $t2		# copia o numero pra a0, vamos passar a0 para a funcao is_lower_than_parameter
jal is_lower_than_parameter	# chama a funcao para verificar se o numero atende aos parametros do enunciado
#fzr um beq
beq $v1, $zero, end	# se v1 = 0, retorno da funcao indica erro. Assim, termina-se o programa

# verificar se o t2 e primo
move $a0, $t2		# copia o numero pra a0, vamos passar a0 para a funcao is_prime
jal is_prime
beq $v1, $zero, end	# se v1 = 0, retorno da funcao indica erro. Assim, termina-se o programa

# exponenciar tudo

move $t8, $t1			# copia t1 pra t8

divu $t0, $t2 
mfhi $t5
sub $t4, $t4, $t4
addi $t4, $t4, 1
for:
beq $t8, $zero, sai_do_for
andi $t7, $t1, 1
bne $t7, 1, pula
multu $t4, $t5
mflo $t4
divu $t4, $t2
mfhi $t4
pula:
multu $t5, $t5
mflo $t5
divu $t5, $t2
mfhi $t5
srl $t8, $t8, 1
j for
sai_do_for:

li $v0, 4
la $a0, exp_mod
syscall

move $a0, $t0
li $v0, 1
syscall

li $v0, 4
la $a0, elevado
syscall

li $v0, 1
move $a0, $t1
syscall

li $v0, 4
la $a0, mod
syscall

li $v0, 1
move $a0, $t2
syscall 

li $v0, 4
la $a0, fecha_mod
syscall

# resultado em t4
move $a0, $t4			# resultado agora em a0
li $v0, 1			# print int code
syscall 			# print do resultado

li $v0, 4
la $a0, barra_n
syscall

end:
#------END-----------------------------------------------------------------------------------------------------#
li $v0, 10 		# codigo de saida de programa
syscall			# chama a syscall para return 0

#---------------------------FUNCOES----------------------------------------------------------------------------#

is_lower_than_parameter:
slt $t3, $a0, $t9	# a0 < 65536 ? t3 = 1, else t3 = 0
beq $t3, $zero, error	# se t3 = 0 , erro.
# verificar se o num <= 0
beq $a0, $zero, error	# se numero = 0, erro
slti $t3, $a0, 0	# se numero < 0, t3 =1, else t3 = 0
bne $t3, $zero, error	# se t3 != 0, erro
sub $v1, $v1, $v1	# v1 = 0, endereco de retorno de funcao
addi $v1, $v1, 1	# v1 = 1, retorno verdadeiro

jr $ra

error:
# print da mensagem de erro
li $v0, 4		# cod print string
la $a0, mensagem_de_erro # carrega a mensagem no a0
syscall			# print mensagem de erro
sub $v1, $v1, $v1	# v1 = 0, endereco de retorno de funcao, 0 = erro
jr $ra			# volta para onde parou

is_prime:
# verificar se o num <= 3
slti $t3, $a0, 4	# se numero < 4, t3 =1, else t3 = 0
beq $t3, $zero, verifica_mod_2_3	# se t3 = 0, num >= 4, pula pro outro if
beq $a0, 1, not_prime	# se num = 1 , nao e primo
# ver se num = 2
addi $t7, $zero, 2	# t7 = 2
beq $a0, $t7, sai_do_while	# se num for 2, e primo
# ver se num = 3
addi $t7, $t7, 1	# t7 = 3
beq $a0, $t7, sai_do_while	# se num = 3 , e primo

verifica_mod_2_3:
divu $a0, $t6		# num / 2 -> HI = resto
mfhi $t5		# t5 = resto (HI)
beq $t5, $zero, not_prime	# se o resto da div for 0, nao e primo
divu $a0, $t8		# num / 3 -> HI = resto
mfhi $t5		# t5 = resto de num/3
beq $t5, $zero, not_prime 	# se o resto da div for 0, nao e primo

addi $t5, $a0, 1	# t5 = num + 1
while:
slt $t3, $t4, $t5	# t4 < num + 1 ? t3 = 1, else t3 = 0 ; t4 = 25, inicialmente
beq $t3, $zero, sai_do_while	# se t4 > num + 1 sai do while
div $a0, $t4		# num / t4 
mfhi $t5		# t5 = resto de num / t4
beq $t5, $zero, not_prime	# se o resto da div for 0, nao e primo
addi $t4, $t4, 2	# t4 + 2
div $a0, $t4		# num / t4+2
mfhi $t5		# t5 = resto de num / t4+2
beq $t5, $zero, not_prime	# se o resto da div for 0, nao e primo
addi $t4, $t4, 4	# t4 = t4 + 4
addi $t5, $a0, 1	# t5 = num + 1
# fazer t4 * t4 => i * i
multu $t4, $t4		# t4 ^ 2
mflo $t4		# t4 = low t4^2
j while

sai_do_while:
sub $v1, $v1, $v1	# v1 = 0, endereco de retorno de funcao
addi $v1, $v1, 1	# v1 = 1, retorno verdadeiro

jr $ra

not_prime:
# print da mensagem de erro
li $v0, 4		# cod print string
la $a0, nao_primo	# carrega a mensagem no a0
syscall			# print mensagem de erro
sub $v1, $v1, $v1	# v1 = 0, endereco de retorno de funcao, 0 = erro
jr $ra			# volta para onde parou
